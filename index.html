<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AnimX</title>
  <style>
    :root{
      --bg:#0f1115; --ui:#151a22; --ui2:#10141c; --line:#2a3140;
      --text:#e8ecf2; --muted:#9aa4b2; --accent:#00d0ff; --danger:#ff4444;
      --canvas:#ffffff; --kofi:#ff5e5b;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui, sans-serif;
      background:var(--bg); color:var(--text); height:100vh; overflow:hidden;
    }

    /* Top Bar */
    .topbar{
      height:54px; background:linear-gradient(180deg, #0f131b, #0b0e14);
      border-bottom:1px solid var(--line); display:flex; align-items:center; padding:0 12px; gap:12px;
    }
    .brand{ font-weight:700; font-size:13px; padding:6px 10px; border:1px solid var(--line); background:#0d1016; border-radius:10px; }
    .tabs{ display:flex; gap:6px; align-items:center; }
    .tab{
      border:1px solid var(--line); background:#0d1118; color:var(--text); padding:8px 12px; border-radius:10px; font-size:12px; cursor:pointer; user-select:none;
    }
    .tab.on{ border-color:var(--accent); box-shadow:0 0 0 1px rgba(0,208,255,.25) inset; }
    
    .support-link{ 
      margin-left:auto; text-decoration:none; display:flex; align-items:center; gap:6px;
      font-size:11px; color:var(--text); padding:6px 12px; border:1px solid var(--line); 
      border-radius:10px; background:#0d1016; transition: 0.2s;
    }
    .support-link:hover{ border-color: var(--kofi); background: rgba(255, 94, 91, 0.1); }
    .support-link img{ height:14px; }

    /* Layout */
    .main{ height:calc(100vh - 54px); display:grid; grid-template-columns: 240px 1fr 260px; gap:12px; padding:12px; }
    .panel{ background:var(--ui); border:1px solid var(--line); border-radius:14px; padding:12px; display:flex; flex-direction:column; gap:10px; min-height:0; overflow-y:auto; }
    .panel h3{ margin:0 0 4px; font-size:12px; color:var(--muted); letter-spacing:0.2px; border-bottom:1px solid #222; padding-bottom:4px; display:flex; justify-content:space-between; align-items:center; }
    
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
   .btn{ 
      border:1px solid var(--line); 
      background:var(--ui2); color:var(--text); padding:8px 10px; border-radius:12px; 
      font-size:12px; cursor:pointer; user-select:none; text-align:center; flex:1; transition:0.1s;
      
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:hover{ filter:brightness(1.2); }
    .btn.active{ background:var(--accent); color:#000; border-color:var(--accent); font-weight:bold; }
    .btn.danger{ border-color:rgba(255,68,68,.5); color:#ffaaaa; }
    .btn.accent{ border-color:rgba(0,208,255,.55); color:#ccf8ff; }
    .btn.small{ padding:4px 8px; font-size:11px; border-radius:8px; flex:initial; }
    .sep{ height:1px; background:#222a38; margin:6px 0; }

    label{ display:flex; justify-content:space-between; font-size:11px; color:var(--muted); margin-top:6px; }
    input[type="range"]{ width:100%; margin:4px 0; }

    /* Toggle Switch */
    .toggle { appearance:none; width:28px; height:16px; background:#222; border-radius:10px; border:1px solid #444; position:relative; outline:none; cursor:pointer; vertical-align:middle; }
    .toggle::after { content:''; position:absolute; top:1px; left:1px; width:12px; height:12px; background:#666; border-radius:50%; transition:0.2s; }
    .toggle:checked { background:var(--accent); border-color:var(--accent); }
    .toggle:checked::after { left:13px; background:#000; }

    .tabSlot{ display:none; }
    .tabSlot.on{ display:block; }

    /* Control Groups */
    .grp-gpen, .grp-shadow { display:none; }
    .show-gpen .grp-gpen { display:block; }
    .show-shadow .grp-shadow { display:block; }

    /* Stage Area (Scrollable) */
    .stageWrap{ 
      background:var(--ui); border:1px solid var(--line); border-radius:14px; padding:12px; 
      min-height:0; display:flex; flex-direction:column; gap:10px; 
      overflow: hidden; 
    }
    
    /* FIX: Use CSS Grid + Auto Margins for perfect center/scroll behavior */
    .stageContainer {
      flex: 1; 
      overflow: auto; 
      background: #101216; 
      border-radius: 4px;
      display: grid; /* Grid is robust for this */
      /* No place-items: center here, let margin:auto do it to preserve scroll */
    }

    /* Invisible wrapper to force scrollbars when zoomed */
    #canvasScaleTarget {
      margin: auto; /* KEY: Centers content if smaller than view, stays put if larger */
      display: block;
      position: relative;
      /* Size will be set by JS */
    }
    
    /* Stage (The actual canvas) */
    .stage{ 
      position: relative; 
      background: var(--canvas); 
      overflow: hidden; touch-action: none; 
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      cursor: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12,2 L12,22 M2,12 L22,12" stroke="white" stroke-width="3" stroke-linecap="round"/><path d="M12,2 L12,22 M2,12 L22,12" stroke="black" stroke-width="1" stroke-linecap="round"/></svg>') 12 12, crosshair;
      
      transform-origin: 0 0;
    }

    #refContainer {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      overflow: hidden; z-index: 0;
      opacity: 0.5; pointer-events: none;
      width: 280px; height: 300px; display: none; 
    }
    #refImage {
      display: block; position: absolute; top: 0; left: 0;
      transform-origin: 0 0; will-change: transform;
    }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; z-index: 10; }

    .stageHeader{ display:flex; align-items:center; gap:10px; flex:0 0 auto; }
    .stageHeader .mini{ font-size:11px; color:var(--muted); }

    .layersList{ overflow:auto; border:1px solid #1f2633; border-radius:12px; background:#0e121a; padding:8px; flex:1; }
    .layerItem{ border:1px solid #263045; background:#101624; border-radius:8px; padding:6px 8px; margin-bottom:4px; display:flex; gap:8px; align-items:center; cursor:pointer; user-select:none; }
    .layerItem.on{ border-color:rgba(0,208,255,.55); background:#1a202c; }
    .eye{ width:24px; text-align:center; cursor:pointer; font-size:14px; }
    .lname{ flex:1; font-size:12px; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; }
    .op{ font-size:10px; color:var(--muted); width:30px; text-align:right; }
    .moveBtns{ display:flex; flex-direction:column; gap:2px; }
    .moveBtn{ font-size:8px; padding:2px 4px; border:1px solid var(--line); border-radius:4px; cursor:pointer; background:#222; color:#aaa; line-height:1; }
    .moveBtn:hover{ background:var(--accent); color:#000; }
  
    /* AnimX Animation UI */
    .animThumbs{ display:grid; grid-template-columns:repeat(2, 1fr); gap:8px; }
    .thumbItem{ border:1px solid var(--line); border-radius:10px; padding:6px; cursor:pointer; background:rgba(255,255,255,0.02); }
    .thumbItem:hover{ background:rgba(255,255,255,0.04); }
    .thumbImg{ width:100%; height:70px; background:#0a0d12; border-radius:8px; display:flex; align-items:center; justify-content:center; overflow:hidden; }
    .thumbImg img{ width:100%; height:100%; object-fit:contain; image-rendering:pixelated; }
    .thumbName{ margin-top:6px; font-size:11px; opacity:0.85; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .animSeq{ display:flex; flex-direction:column; gap:6px; max-height:240px; overflow:auto; padding-right:4px; }
    .seqItem{ display:flex; align-items:center; gap:8px; border:1px solid var(--line); border-radius:10px; padding:6px; background:rgba(0,0,0,0.2); cursor:grab; }
    .seqItem.on{ outline:2px solid var(--accent); }
    .seqThumb{ width:52px; height:38px; border-radius:8px; overflow:hidden; background:#0a0d12; flex:0 0 auto; }
    .seqThumb img{ width:100%; height:100%; object-fit:contain; image-rendering:pixelated; }
    .seqLabel{ flex:1; font-size:11px; opacity:0.85; }
    .seqBtns{ display:flex; gap:6px; }
    .seqBtn{ font-size:11px; padding:4px 8px; border:1px solid var(--line); border-radius:10px; cursor:pointer; user-select:none; }
    .seqBtn:hover{ background:rgba(255,255,255,0.04); }

</style>
</head>

<body>
<div class="topbar">
  <a href="https://dim.productions/" target="_blank" style="display:flex; align-items:center; text-decoration:none; gap:10px;">
    <img src="source/dimplogo.svg" alt="DIM Logo" style="height:32px; width:auto;">
  </a>

  <div class="tabs">
    <div class="brand">AnimX</div>
    <div class="tab on" data-tab="draw">DRAW</div>
    <div class="tab" data-tab="export">INPORT/EXPORT</div>
    <div class="tab" data-tab="anim">ANIM</div>
  </div>

  <a href="https://ko-fi.com/dimproductions" target="_blank" class="support-link">
    <img src="https://storage.ko-fi.com/cdn/cup-border.png" alt="Ko-fi">
    <span>Support us</span>
  </a>
</div>

  <div class="main">
    <div class="panel">
      
      <div id="slot-draw" class="tabSlot on show-gpen"> 
        <h3>TOOLS</h3>
        <div class="row">
          <div class="btn active" id="toolPen">G-Pen</div>
          <div class="btn" id="toolShadow">Shadow</div>
          <div class="btn" id="toolEraser">Eraser</div>
        </div>
        <div class="row" style="margin-top:8px;">
           <div class="btn" id="toolSelect">Select</div>
        </div>
        <div class="row" style="margin-top:8px;">
            <div class="btn small" id="btnUndo">‚Ü∂ Undo</div>
            <div class="btn small" id="btnRedo">‚Ü∑ Redo</div>
        </div>
        <div class="row" style="margin-top:8px;">
            <div class="btn small" id="btnCopy">‚éò Copy</div>
            <div class="btn small" id="btnCut">‚úÇ Cut</div>
            <div class="btn small danger" id="btnDelete">‚å´ Delete</div>
            <div class="btn small" id="btnPaste">‚éò Paste</div>
        </div>

        <div class="row" style="margin-top:8px;">
            <div class="btn small active" id="dragModeMove">Drag: Move</div>
            <div class="btn small" id="dragModeCopy">Drag: Copy</div>
        </div>

        <div class="sep"></div>
        <h3>CANVAS ZOOM</h3>
        <label>Zoom <span id="vCanvasZoom">100%</span></label>
        <input id="canvasZoom" type="range" min="10" max="400" value="100" step="10">

        <div class="sep"></div>
        <h3>PEN SETTINGS</h3>
        <label>Size <span id="vSize">4.0</span></label>
        <input id="penSize" type="range" min="1" max="100" value="4">
        
        <div class="grp-gpen">
            <label>Taper <span id="vTaper">0.5</span></label>
            <input id="penTaper" type="range" min="0" max="1" value="0.5" step="0.05">
            <label>Pressure <span id="vPress">0.8</span></label>
            <input id="penPress" type="range" min="0" max="1" value="0.8" step="0.05">
            <label>Smooth <span id="vSmooth">0.4</span></label>
            <input id="penSmooth" type="range" min="0" max="0.95" value="0.4" step="0.05">
        </div>

        <div class="grp-shadow">
            <label title="Lower = more layers needed to darken">Flow (Opacity) <span id="vFlow">0.08</span></label>
            <input id="shadowFlow" type="range" min="0.01" max="0.5" value="0.08" step="0.01">
            <label title="Edge softness and spread">Wet (Bleed) <span id="vWet">0.75</span></label>
            <input id="shadowWet" type="range" min="0.1" max="1.0" value="0.75" step="0.05">
        </div>

        <div class="sep"></div>
        <h3>
            REFERENCE (3D)
            <input type="checkbox" id="refToggle" class="toggle" checked title="Toggle Reference ON/OFF">
        </h3>
        
        <label>Yaw (Rotate) <span id="vYaw">0¬∞</span></label>
        <input id="traceYaw" type="range" min="-2" max="2" step="1" value="0">
        
        <label>Pitch (Tilt) <span id="vPitch">0¬∞</span></label>
        <input id="tracePitch" type="range" min="-2" max="2" step="1" value="0">
        
        <label>Opacity <span id="vRefOp">0.5</span></label>
        <input id="refOp" type="range" min="0" max="1" step="0.05" value="0.5">

        <div class="sep"></div>
        <div class="btn danger" id="btnClearActive">Clear Layer</div>
      </div>

      <div id="slot-export" class="tabSlot">
        <h3>EXPORT</h3>
        <div class="btn accent" id="btnImportANIMX">Import .animx</div>
        <div class="btn accent" id="btnExportANIMX">Export .animx</div>
        <div class="btn accent" id="btnExportPNG">Export PNG</div>
        <input id="fileImportAnimx" type="file" accept="*" style="display:none" />
        <div class="btn accent" id="btnExportAnimWebP">Export Animated WebP</div>
        <div class="btn accent" id="btnExportAnimMP4">Export MP4(iPad)</div> 
        <div class="hint" style="margin-top:8px; font-size:10px;">Saves canvas + reference.</div>
      </div>

      <div id="slot-anim" class="tabSlot">
        <h3>ANIMATION</h3>
        <div class="row" style="margin-top:8px;">
          <div class="btn small" id="btnAnimPlay">Play</div>
          <div class="btn small" id="btnAnimStop">Stop</div>
        </div>
        <label style="margin-top:8px;">FPS <span id="vAnimFps">12</span></label>
        <input id="animFps" type="range" min="1" max="30" value="12" step="1">
        <label style="margin-top:8px;">Loop (0=‚àû) <span id="vAnimLoop">0</span></label>
        <input id="animLoop" type="range" min="0" max="30" value="0" step="1">
        <div class="sep"></div>
        <div class="hint" style="font-size:10px; margin-bottom:6px;">Thumbnails = LAYERS. Click to append. Drag in Sequence to reorder.</div>
        <div class="animThumbs" id="animThumbs"></div>
        <div class="sep"></div>
        <h3 style="margin-top:0;">SEQUENCE</h3>
        <div class="animSeq" id="animSeq"></div>
      </div>
    </div>

    <div class="stageWrap">
      <div class="stageHeader"><div class="mini">Canvas: Auto-Fit</div></div>
      <div class="stageContainer">
        <div id="canvasScaleTarget"> <div class="stage" id="stage">
                <div id="refContainer">
                    <img id="refImage" src="source/loomis_source.svg" alt="Loomis Grid">
                </div>
                <canvas id="composite"></canvas>
                <canvas id="input"></canvas>
            </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>LAYERS</h3>
      <div class="row">
        <div class="btn accent small" id="btnAddLayer">+ New</div>
        <div class="btn small" id="btnDupLayer">Copy</div>
        <div class="btn danger small" id="btnDelLayer">Del</div>
      </div>
      <label>Opacity <span id="vLayerOp">1.0</span></label>
      <input id="layerOpacity" type="range" min="0" max="1" value="1" step="0.01">
      <div class="sep"></div>
      <div class="layersList" id="layersList"></div>
    </div>
  </div>

<script>
(() => {
  const tabs = document.querySelectorAll('.tab');
  const slots = { draw:document.getElementById('slot-draw'), export:document.getElementById('slot-export'), anim:document.getElementById('slot-anim') };
  const refContainer = document.getElementById('refContainer'); 
  let currentTab = 'draw';

  function setTab(m){
    currentTab = m;
    tabs.forEach(t=>t.classList.toggle('on', t.dataset.tab===m));
    Object.values(slots).forEach(e=>e && e.classList.remove('on'));
    if(slots[m]) slots[m].classList.add('on');
    // Tab-specific view refresh
    if(m==='anim'){ updateAnimUI(); renderAnimFrame(activeAnimIdx); }
    else { stopAnimPlayback(); redrawComposite(); }
  }
  tabs.forEach(t=>t.addEventListener('click',()=>setTab(t.dataset.tab)));

  const stage=document.getElementById('stage'), cComp=document.getElementById('composite'), cInput=document.getElementById('input');
  const gComp=cComp.getContext('2d'), gInput=cInput.getContext('2d');
  
  // Base dimensions (physical)
  let baseW=800, baseH=600;

  function resizeCanvasBase(){
    const cont = document.querySelector('.stageContainer');
    const r = cont.getBoundingClientRect();
    // Default: fit to container minus padding
    baseW = Math.floor(r.width - 40); 
    baseH = Math.floor(r.height - 40);
    if(baseW<100) baseW=100; if(baseH<100) baseH=100;
    
    // Set internal resolution
    cComp.width = cInput.width = baseW;
    cComp.height = cInput.height = baseH;
    
    // Set initial display size (100%)
    applyZoom(1.0);
    
    ensureLayerSize(); redrawComposite();
    history = []; historyStep = -1; 
  }
  
  // Zoom logic
  const elZoom = document.getElementById('canvasZoom');
  const vZoom = document.getElementById('vCanvasZoom');
  const elScaleTarget = document.getElementById('canvasScaleTarget');
  const stageContainer = document.querySelector('.stageContainer');
  let currentScale = 1.0;
  
  function applyZoom(scale){
    currentScale = scale;
    stage.style.width = baseW + 'px';
    stage.style.height = baseH + 'px';
    stage.style.transform = `scale(${scale})`;
    
    const targetW = Math.floor(baseW * scale);
    const targetH = Math.floor(baseH * scale);
    elScaleTarget.style.width = targetW + 'px';
    elScaleTarget.style.height = targetH + 'px';
  }

  // Slider Zoom -> Zoom to Center
  elZoom.oninput = (e) => {
    const nextScale = +e.target.value / 100;
    vZoom.innerText = +e.target.value + '%';
    const rect = stageContainer.getBoundingClientRect();
    const cx = rect.width / 2;
    const cy = rect.height / 2;
    zoomToPoint(nextScale, cx, cy);
  };

  function zoomToPoint(nextScale, ox, oy){
    const pX = (ox + stageContainer.scrollLeft) / currentScale;
    const pY = (oy + stageContainer.scrollTop) / currentScale;
    applyZoom(nextScale);
    stageContainer.scrollLeft = (pX * nextScale) - ox;
    stageContainer.scrollTop = (pY * nextScale) - oy;
  }

  // Wheel zoom -> Zoom to Mouse
  stageContainer.addEventListener('wheel', (e) => {
    if (e.ctrlKey) {
      e.preventDefault();
      const rect = stageContainer.getBoundingClientRect();
      const ox = e.clientX - rect.left;
      const oy = e.clientY - rect.top;
      const delta = e.deltaY > 0 ? -10 : 10;
      let nextVal = Math.round(currentScale * 100) + delta;
      nextVal = Math.max(10, Math.min(400, nextVal)); 
      const nextScale = nextVal / 100;
      elZoom.value = nextVal;
      vZoom.innerText = nextVal + '%';
      zoomToPoint(nextScale, ox, oy);
    }
  }, { passive: false });

  window.addEventListener('load', resizeCanvasBase);

  let layers=[], activeIdx=0;
  let selection = { active:false, x:0,y:0,w:0,h:0, img:null, moving:false, startX:0,startY:0, baseX:0, baseY:0, origin:null };
  let selectionPointerId = null; 
  let dragMode = 'move'; 
  let lastPointer = {x:0,y:0};
  let __layerSeq=0;
  
  // AnimX animation state
  let animFrames=[];
  let activeAnimIdx=0;
  let animPlaying=false;
  let animTimer=null;
  let animLoopsRemaining=0;

  function makeCanvas(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }
  
  function addLayer(name){
    const c=makeCanvas(cComp.width, cComp.height);
    const id = `L${Date.now().toString(36)}_${(__layerSeq++).toString(36)}`;
    layers.unshift({id, name, visible:true, opacity:1, canvas:c, ctx:c.getContext('2d', {willReadFrequently:true})});
    activeIdx=0; updateLayerUI();
  }
  function moveLayer(idx, dir){
    const newIdx = idx + dir;
    if(newIdx < 0 || newIdx >= layers.length) return;
    const tmp = layers[idx]; layers[idx] = layers[newIdx]; layers[newIdx] = tmp;
    if(activeIdx === idx) activeIdx = newIdx; else if(activeIdx === newIdx) activeIdx = idx;
    updateLayerUI(); redrawComposite();
  }
  function updateLayerUI(){
    const list=document.getElementById('layersList'); list.innerHTML='';
    layers.forEach((L,i)=>{
      if(!L.id) L.id = `L${Date.now().toString(36)}_${(__layerSeq++).toString(36)}`;
      const el=document.createElement('div');
      el.className=`layerItem ${i===activeIdx?'on':''}`;
      el.innerHTML=`
        <div class="eye">${L.visible?'üëÅ':'¬∑'}</div>
        <div class="lname">${L.name}</div>
        <div class="moveBtns"><div class="moveBtn up">‚ñ≤</div><div class="moveBtn down">‚ñº</div></div>
        <div class="op">${L.opacity.toFixed(1)}</div>
      `;
      el.querySelector('.eye').onclick=(e)=>{e.stopPropagation(); L.visible=!L.visible; updateLayerUI(); redrawComposite();};
      el.querySelector('.moveBtn.up').onclick=(e)=>{e.stopPropagation(); moveLayer(i, -1);};
      el.querySelector('.moveBtn.down').onclick=(e)=>{e.stopPropagation(); moveLayer(i, 1);};
      el.onclick=()=>{activeIdx=i; updateLayerUI(); syncLayerOp();};
      list.appendChild(el);
    });
    updateAnimUI();
    ensureLayerSize(); redrawComposite();
  }
  function redrawComposite(){
    gComp.clearRect(0,0,cComp.width,cComp.height);
    for(let i=layers.length-1; i>=0; i--){ const L=layers[i]; if(L.visible){ gComp.globalAlpha=L.opacity; gComp.drawImage(L.canvas,0,0); } }

    if(currentTab==='draw' && toolType==='select' && selection.active){
      const nx = Math.min(selection.x, selection.x + selection.w);
      const ny = Math.min(selection.y, selection.y + selection.h);
      const nw = Math.abs(selection.w), nh = Math.abs(selection.h);
      gComp.save();
      gComp.globalAlpha = 1.0;
      gComp.setLineDash([6,4]);
      gComp.lineWidth = 2;
      gComp.strokeStyle = 'rgba(0,0,0,0.85)';
      gComp.strokeRect(nx+0.5, ny+0.5, nw, nh);
      gComp.lineWidth = 1;
      gComp.strokeStyle = 'rgba(0,208,255,0.95)';
      gComp.strokeRect(nx+0.5, ny+0.5, nw, nh);
      gComp.setLineDash([]);
      if(selection.moving && selection.img){
        gComp.globalAlpha = 0.85;
        gComp.putImageData(selection.img, nx, ny);
      }
      gComp.restore();
    }
  }
  function ensureLayerSize(){
    layers.forEach(L=>{
      if(L.canvas.width!==cComp.width || L.canvas.height!==cComp.height){
        const c=makeCanvas(cComp.width, cComp.height); 
        const cx=c.getContext('2d', {willReadFrequently:true});
        cx.drawImage(L.canvas,0,0); 
        L.canvas=c; L.ctx=cx;
      }
    });
  }

  // Animation UI & Logic
  const elAnimThumbs = document.getElementById('animThumbs');
  const elAnimSeq = document.getElementById('animSeq');
  const elAnimFps = document.getElementById('animFps');
  const elAnimLoop = document.getElementById('animLoop');
  const vAnimFps = document.getElementById('vAnimFps');
  const vAnimLoop = document.getElementById('vAnimLoop');

  function getLayerById(id){ return layers.find(L=>L.id===id) || null; }

  function layerThumbURL(L){
    const tw=220, th=140;
    const t=makeCanvas(tw, th);
    const g=t.getContext('2d');
    g.clearRect(0,0,tw,th);
    const sw=L.canvas.width, sh=L.canvas.height;
    if(sw>0 && sh>0){
      const s = Math.min(tw/sw, th/sh);
      const dw = Math.floor(sw*s), dh = Math.floor(sh*s);
      const dx = Math.floor((tw-dw)/2), dy = Math.floor((th-dh)/2);
      g.drawImage(L.canvas, 0,0,sw,sh, dx,dy,dw,dh);
    }
    return t.toDataURL('image/png');
  }

  function updateAnimUI(){
    if(!elAnimThumbs || !elAnimSeq) return;
    elAnimThumbs.innerHTML='';
    layers.forEach((L)=>{
      const item=document.createElement('div');
      item.className='thumbItem';
      const src = layerThumbURL(L);
      item.innerHTML = `
        <div class="thumbImg"><img draggable="false" src="${src}"></div>
        <div class="thumbName">${L.name}</div>
      `;
      item.onclick=()=>{ animFrames.push(L.id); activeAnimIdx = animFrames.length-1; updateAnimUI(); renderAnimFrame(activeAnimIdx); };
      elAnimThumbs.appendChild(item);
    });

    elAnimSeq.innerHTML='';
    animFrames.forEach((layerId, idx)=>{
      const L=getLayerById(layerId);
      const item=document.createElement('div');
      item.className = `seqItem ${idx===activeAnimIdx?'on':''}`;
      item.draggable = true;
      const src = L ? layerThumbURL(L) : '';
      const label = L ? L.name : '(missing layer)';
      item.innerHTML = `
        <div class="seqThumb">${src?`<img draggable="false" src="${src}">`:''}</div>
        <div class="seqLabel">${idx+1}. ${label}</div>
        <div class="seqBtns">
          <div class="seqBtn" data-act="dup">Copy</div>
          <div class="seqBtn" data-act="del">Del</div>
        </div>
      `;
      item.onclick=()=>{ activeAnimIdx=idx; updateAnimUI(); renderAnimFrame(activeAnimIdx); };
      item.querySelector('[data-act="dup"]').onclick=(e)=>{ e.stopPropagation(); animFrames.splice(idx+1,0,layerId); activeAnimIdx=idx+1; updateAnimUI(); renderAnimFrame(activeAnimIdx); };
      item.querySelector('[data-act="del"]').onclick=(e)=>{ e.stopPropagation(); animFrames.splice(idx,1); if(activeAnimIdx>=animFrames.length) activeAnimIdx=Math.max(0, animFrames.length-1); updateAnimUI(); renderAnimFrame(activeAnimIdx); };
      item.addEventListener('dragstart', (e)=>{ e.dataTransfer.setData('text/plain', String(idx)); });
      item.addEventListener('dragover', (e)=>{ e.preventDefault(); });
      item.addEventListener('drop', (e)=>{
        e.preventDefault();
        const from = Number(e.dataTransfer.getData('text/plain'));
        const to = idx;
        if(Number.isNaN(from) || from===to) return;
        const [moved] = animFrames.splice(from,1);
        animFrames.splice(to,0,moved);
        activeAnimIdx = to;
        updateAnimUI();
        renderAnimFrame(activeAnimIdx);
      });
      elAnimSeq.appendChild(item);
    });

    if(elAnimFps && vAnimFps) vAnimFps.textContent = String(elAnimFps.value|0);
    if(elAnimLoop && vAnimLoop) vAnimLoop.textContent = String(elAnimLoop.value|0);
  }

  function renderAnimFrame(idx){
    if(currentTab!=='anim'){ return; }
    if(animFrames.length===0){ redrawComposite(); return; }
    if(idx<0 || idx>=animFrames.length) idx=0;
    const L = getLayerById(animFrames[idx]);
    if(!L){ redrawComposite(); return; }
    gComp.clearRect(0,0,cComp.width,cComp.height);
    gComp.globalAlpha = 1.0;
    gComp.drawImage(L.canvas, 0,0);
  }

  function stopAnimPlayback(){
    if(animTimer){ clearInterval(animTimer); animTimer=null; }
    animPlaying=false;
  }

  function startAnimPlayback(){
    if(currentTab!=='anim') return;
    if(animFrames.length===0) return;
    stopAnimPlayback();
    animPlaying=true;
    const fps = Math.max(1, Number(elAnimFps?.value||12));
    const loop = Number(elAnimLoop?.value||0);
    animLoopsRemaining = loop;
    let i = activeAnimIdx||0;
    const frameMs = Math.floor(1000 / fps);
    animTimer = setInterval(()=>{
      if(currentTab!=='anim'){ stopAnimPlayback(); return; }
      renderAnimFrame(i);
      i++;
      if(i>=animFrames.length){
        i=0;
        if(loop>0){
          animLoopsRemaining--;
          if(animLoopsRemaining<=0){
            stopAnimPlayback();
            activeAnimIdx=0;
            updateAnimUI();
            renderAnimFrame(activeAnimIdx);
            return;
          }
        }
      }
      activeAnimIdx = i;
      updateAnimUI();
    }, frameMs);
  }

const btnAnimPlay = document.getElementById('btnAnimPlay');
  const btnAnimStop = document.getElementById('btnAnimStop');


  btnAnimPlay && (btnAnimPlay.onpointerdown = (e)=>{ e.preventDefault(); startAnimPlayback(); });
  btnAnimStop && (btnAnimStop.onpointerdown = (e)=>{ e.preventDefault(); stopAnimPlayback(); renderAnimFrame(activeAnimIdx); });
  elAnimFps && (elAnimFps.oninput = ()=>{ updateAnimUI(); });
  elAnimLoop && (elAnimLoop.oninput = ()=>{ updateAnimUI(); });

  function syncLayerOp(){
    if(layers[activeIdx]){ const op=layers[activeIdx].opacity; document.getElementById('layerOpacity').value=op; document.getElementById('vLayerOp').innerText=op.toFixed(2); }
  }

  let history = []; let historyStep = -1; const MAX_HISTORY = 20; let strokeStartData = null; 
  function recordHistory(oldData, newData, lIdx){
    if(historyStep < history.length - 1){ history = history.slice(0, historyStep + 1); }
    history.push({ layerIdx: lIdx, before: oldData, after: newData });
    if(history.length > MAX_HISTORY) history.shift(); else historyStep++;
    updateUndoUI();
  }
  function performUndo(){
    if(historyStep < 0) return;
    const action = history[historyStep];
    if(layers[action.layerIdx]){ layers[action.layerIdx].ctx.putImageData(action.before, 0, 0); redrawComposite(); }
    historyStep--; updateUndoUI();
  }
  function performRedo(){
    if(historyStep >= history.length - 1) return;
    historyStep++;
    const action = history[historyStep];
    if(layers[action.layerIdx]){ layers[action.layerIdx].ctx.putImageData(action.after, 0, 0); redrawComposite(); }
    updateUndoUI();
  }
  function updateUndoUI(){
    document.getElementById('btnUndo').style.opacity = historyStep >= 0 ? '1' : '0.5';
    document.getElementById('btnRedo').style.opacity = historyStep < history.length - 1 ? '1' : '0.5';
  }
  document.getElementById('btnUndo').onclick = performUndo;
  document.getElementById('btnRedo').onclick = performRedo;
  window.addEventListener('keydown', e => {
    if((e.ctrlKey || e.metaKey) && e.key === 'z'){ e.preventDefault(); e.shiftKey ? performRedo() : performUndo(); }
    if((e.ctrlKey || e.metaKey) && e.key === 'y'){ e.preventDefault(); performRedo(); }
  });

  let drawing=false, pts=[]; let toolType = 'pen';
  const penSettings = { size:4, press:0.8, smooth:0.4, taper:0.5 };

  const shadowSettings = { flow:0.04, wet:0.82, grain:0.25, spacing:0.12, edgeDark: 0.55 };

  function setTool(t){
    toolType=t;
    document.getElementById('toolPen').classList.toggle('active', t==='pen');
    document.getElementById('toolShadow').classList.toggle('active', t==='shadow');
    document.getElementById('toolEraser').classList.toggle('active', t==='eraser');
    document.getElementById('toolSelect').classList.toggle('active', t==='select');
    
    const panel = document.getElementById('slot-draw');
    if(t === 'pen' || t === 'eraser') {
        panel.classList.add('show-gpen'); panel.classList.remove('show-shadow');
    } else if(t === 'shadow') {
        panel.classList.remove('show-gpen'); panel.classList.add('show-shadow');
    } else {
        panel.classList.remove('show-gpen'); panel.classList.remove('show-shadow');
    }
    redrawComposite();
  }

  document.getElementById('toolPen').onclick=()=>setTool('pen');
  document.getElementById('toolShadow').onclick=()=>setTool('shadow');
  document.getElementById('toolEraser').onclick=()=>setTool('eraser');
  document.getElementById('toolSelect').onclick=()=>setTool('select');

  const bindSet = (id, key, dispId, obj=penSettings) => {
    document.getElementById(id).oninput=(e)=>{ obj[key] = +e.target.value; if(dispId) document.getElementById(dispId).innerText = obj[key]; };
  };
  bindSet('penSize','size','vSize'); 
  bindSet('penPress','press','vPress'); 
  bindSet('penSmooth','smooth','vSmooth'); 
  bindSet('penTaper','taper','vTaper');
  
  bindSet('shadowFlow', 'flow', 'vFlow', shadowSettings);
  bindSet('shadowWet', 'wet', 'vWet', shadowSettings);

  // --- Watercolor Stamp Logic (FIXED HARD EDGE) ---
  let wcStampCache = new Map();
  function makeWatercolorStamp(size, wet=0.7, grain=0.35, edgeDark=0.85){
    const s = Math.max(6, Math.floor(size));
    const key = `${s}|${wet.toFixed(2)}|${grain.toFixed(2)}`;
    if(wcStampCache.has(key)) return wcStampCache.get(key);

    const c = document.createElement('canvas');
    c.width = c.height = s*2;
    const g = c.getContext('2d');
    const cx = c.width/2, cy = c.height/2;
    const r = s*(0.85 + wet*0.25);

    const grad = g.createRadialGradient(cx, cy, 0, cx, cy, r);

    grad.addColorStop(0.00, `rgba(0,0,0,0.02)`);

    grad.addColorStop(0.85, `rgba(0,0,0,${0.08 + 0.15*edgeDark})`);

    grad.addColorStop(1.00, `rgba(0,0,0,0)`);

    g.fillStyle = grad;
    g.beginPath();
    g.arc(cx, cy, r, 0, Math.PI*2);
    g.fill();

    if(grain > 0){
        const img = g.getImageData(0,0,c.width,c.height);
        const d = img.data;
        for(let i=0;i<d.length;i+=4){
            if(d[i+3]>0){ 
                const n = (Math.random()*2-1) * 60 * grain; 
                d[i+3] = Math.max(0, Math.min(255, d[i+3] + n));
            }
        }
        g.putImageData(img,0,0);
    }
    wcStampCache.set(key, c);
    return c;
  }

  function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
  function lerp(a,b,t){ return a+(b-a)*t; }
  function smoothstep(t){ t=clamp(t,0,1); return t*t*(3-2*t); }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function getStrokeLengths(pts){ const lens=[0]; let total=0; for(let i=1; i<pts.length; i++){ total += dist(pts[i-1], pts[i]); lens.push(total); } return {lens, total}; }
  function getWidthAt(tNorm, pressure, settings){
    const taperLen = Math.max(0.01, settings.taper); 
    const inT = smoothstep(tNorm / taperLen); const outT = smoothstep((1-tNorm) / taperLen);
    const pFactor = Math.pow(pressure, 1.5); const pressFactor = lerp(1.0 - settings.press, 1.0, pFactor);
    return settings.size * pressFactor * Math.min(inT, outT);
  }

  // ---- Selection (rect) tool ----
  function normRect(x,y,w,h){
    const nx = (w>=0)? x : x+w;
    const ny = (h>=0)? y : y+h;
    return { x: Math.max(0, Math.floor(nx)), y: Math.max(0, Math.floor(ny)), w: Math.max(0, Math.floor(Math.abs(w))), h: Math.max(0, Math.floor(Math.abs(h))) };
  }
  function pointInRect(px,py,r){ return px>=r.x && py>=r.y && px<=(r.x+r.w) && py<=(r.y+r.h); }

  function beginSelect(e){
    const p = evPos(e, cInput);
    if(!layers[activeIdx]) return;
    selection.dragging = true;  
    cInput.setPointerCapture?.(e.pointerId); 
    const r = normRect(selection.x, selection.y, selection.w, selection.h);
    const inside = selection.active && selection.img && pointInRect(p.x, p.y, r);
    selection.startX = p.x; selection.startY = p.y;
    if(inside){
      selection.moving = true;
      selection.baseX = selection.x; selection.baseY = selection.y;
      selection.origin = { x:r.x, y:r.y, w:r.w, h:r.h };
    }else{
      selection.active = true;
      selection.moving = false;
      selection.img = null;
      selection.origin = null;
      selection.x = p.x; selection.y = p.y; selection.w = 0; selection.h = 0;
    }
    redrawComposite();
  }

  function moveSelect(e){
    const p = evPos(e, cInput);
    if(!selection.active) return;
    if(!selection.dragging) return; 
    if(selection.moving){
      const dx = p.x - selection.startX;
      const dy = p.y - selection.startY;
      selection.x = selection.baseX + dx;
      selection.y = selection.baseY + dy;
    }else{
      selection.w = p.x - selection.startX;
      selection.h = p.y - selection.startY;
    }
    redrawComposite();
  }

  function endSelect(e){
    if(!layers[activeIdx]) return;
    const ctx = layers[activeIdx].ctx;
    if(!selection.active) return;
    selection.dragging = false;   
    const r = normRect(selection.x, selection.y, selection.w, selection.h);

    if(!selection.moving){
      if(r.w < 2 || r.h < 2){
        selection.active = false; selection.img = null;
        redrawComposite(); return;
      }
      selection.x = r.x; selection.y = r.y; selection.w = r.w; selection.h = r.h;
      try{ selection.img = ctx.getImageData(r.x, r.y, r.w, r.h); }catch(_){ selection.img=null; }
      redrawComposite(); return;
    }
    selection.moving = false;
    if(!selection.img){
      try{ selection.img = ctx.getImageData(r.x, r.y, r.w, r.h); }catch(_){ selection.img=null; }
    }
    if(!selection.img){ redrawComposite(); return; }
    const before = snapshotLayer(activeIdx);
    const prev = selection.origin || normRect(selection.baseX, selection.baseY, selection.w, selection.h);
    if(dragMode === 'move'){
      ctx.clearRect(prev.x, prev.y, prev.w, prev.h);
    }
    const nx = Math.max(0, Math.min(cComp.width - selection.img.width, Math.floor(selection.x)));
    const ny = Math.max(0, Math.min(cComp.height - selection.img.height, Math.floor(selection.y)));
    ctx.putImageData(selection.img, nx, ny);
    const after = snapshotLayer(activeIdx);
    recordHistory(before, after, activeIdx);
    selection.x = nx; selection.y = ny; selection.w = selection.img.width; selection.h = selection.img.height;
    selection.origin = { x:nx, y:ny, w:selection.img.width, h:selection.img.height };
    redrawComposite();
  }

  window.addEventListener('keydown', e=>{
    if(e.key === 'Escape'){
      if(selection.active){
        selection.active=false; selection.img=null; selection.moving=false; selection.origin=null;
        redrawComposite();
      }
    }
  });

  // ---- Drawing / Input ----
  function evPos(e, canvas){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width / rect.width;
    const sy = canvas.height / rect.height;
    return { x: (e.clientX - rect.left) * sx, y: (e.clientY - rect.top) * sy };
  }

  cInput.addEventListener('pointerdown', e=>{ 
    if(currentTab!=='draw') return;
    const p = evPos(e, cInput);
    lastPointer = {x:p.x, y:p.y};
    if(toolType==='select'){ beginSelect(e); try{ cInput.setPointerCapture(e.pointerId); selectionPointerId = e.pointerId; }catch(_){ } return; }
    if(!layers[activeIdx].visible) return; 
    drawing=true; 
    cInput.setPointerCapture(e.pointerId); 
    pts=[{x:p.x, y:p.y, p:e.pressure||0.5}];
    const ctx = layers[activeIdx].ctx; 
    strokeStartData = ctx.getImageData(0,0, ctx.canvas.width, ctx.canvas.height);
  });

  cInput.addEventListener('pointermove', e=>{ 
    if(currentTab!=='draw') return;
    const p = evPos(e, cInput);
    lastPointer = {x:p.x, y:p.y};
    if(toolType==='select'){ moveSelect(e); return; }
    if(!drawing) return; const raw={x:p.x, y:p.y, p:e.pressure||0.5};
    const k = (toolType === 'shadow') ? 0.3 : (1.0 - penSettings.smooth);
    const last = pts[pts.length-1];
    pts.push({ x: last.x+(raw.x-last.x)*k, y: last.y+(raw.y-last.y)*k, p:raw.p });
    drawPreview(gInput, pts);
  });

  const endStroke = ()=>{
    if(!drawing) return; drawing=false; const ctx = layers[activeIdx].ctx;
    
    if(toolType === 'shadow'){
        ctx.globalCompositeOperation = 'multiply';
        drawStroke(ctx, pts);
        ctx.globalCompositeOperation = 'source-over';
    } else {
        ctx.globalCompositeOperation = (toolType === 'eraser') ? 'destination-out' : 'source-over';
        drawStroke(ctx, pts); 
        ctx.globalCompositeOperation = 'source-over';
    }

    gInput.clearRect(0,0,cInput.width,cInput.height); pts=[]; redrawComposite();
    if(strokeStartData){ recordHistory(strokeStartData, ctx.getImageData(0,0, ctx.canvas.width, ctx.canvas.height), activeIdx); strokeStartData = null; }
  };

  cInput.addEventListener('pointerup', (e) => {
    if (toolType === 'select') {
      if (typeof endSelect === 'function') { endSelect(e); } 
      try { cInput.releasePointerCapture(e.pointerId); } catch (_) {}
      return;
    }
    if(typeof endStroke === 'function') endStroke();
  });

  function drawStroke(ctx, points){
    if(points.length<2) return; 
    
    // === WATERCOLOR SHADOW BRANCH ===
    if(toolType === 'shadow'){
        const stampSize = penSettings.size * 2; 
        const stamp = makeWatercolorStamp(stampSize, shadowSettings.wet, shadowSettings.grain, shadowSettings.edgeDark);
        
        const baseSpacing = shadowSettings.spacing; 
        const flow = shadowSettings.flow;
        
        ctx.save();
        ctx.globalAlpha = flow; 
        
        for(let i=1; i<points.length; i++){
            const p0 = points[i-1], p1 = points[i];
            const dx=p1.x-p0.x, dy=p1.y-p0.y;
            const distVal = Math.hypot(dx,dy);
            if(distVal < 0.5) continue; 

            const speedFactor = Math.min(1.0, 12 / Math.max(1, distVal)); 
            const dynamicSpacing = baseSpacing * (0.6 + 0.4 * speedFactor);

            const stepPx = Math.max(1, stamp.width * dynamicSpacing);
            const n = Math.ceil(distVal / stepPx);
            
            for(let j=0; j<n; j++){
                const t = j/n;
                const x = p0.x + dx*t;
                const y = p0.y + dy*t;
                
                const jx = (Math.random()*2-1)*0.2; // 0.5 -> 0.2
                const jy = (Math.random()*2-1)*0.2;
                
                const press = lerp(p0.p, p1.p, t);
                const currentScale = 0.5 + 0.5*press; 
                const dw = stamp.width * currentScale;
                const dh = stamp.height * currentScale;
                
                ctx.drawImage(stamp, x - dw/2 + jx, y - dh/2 + jy, dw, dh);
            }
        }
        ctx.restore();
        return;
    }

    // === STANDARD GPEN BRANCH ===
    const {lens, total} = getStrokeLengths(points);
    const strength = (toolType === 'eraser') ? 2.4 : 1.0;
    ctx.lineCap='round'; ctx.lineJoin='round'; ctx.globalAlpha = 1.0;
    if(toolType === 'eraser'){
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.lineWidth = penSettings.size;
        ctx.stroke();
        return;
    }
    for(let i=1; i<points.length; i++){
      const t0 = lens[i-1]/total, t1 = lens[i]/total;
      const w0 = getWidthAt(t0, points[i-1].p, penSettings), w1 = getWidthAt(t1, points[i].p, penSettings);
      ctx.beginPath(); ctx.moveTo(points[i-1].x, points[i-1].y); ctx.lineTo(points[i].x, points[i].y);
      ctx.lineWidth = ((w0+w1)*0.5) * strength; ctx.strokeStyle = '#000'; ctx.stroke();
      ctx.beginPath(); ctx.arc(points[i].x, points[i].y, w1/2, 0, Math.PI*2); ctx.fillStyle = '#000'; ctx.fill();
    }
  }

  function drawPreview(ctx, points){
    ctx.clearRect(0,0,ctx.canvas.width, ctx.canvas.height); if(points.length<2) return;
    if(toolType==='eraser'){
      ctx.strokeStyle = '#ffcccc'; ctx.globalAlpha=0.5; ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y); for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
      ctx.lineWidth = penSettings.size; ctx.stroke();
    } else if(toolType === 'shadow'){

      ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = penSettings.size; 
      ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
      for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
      ctx.stroke();
    } else {
      drawStroke(ctx, points);
    }
  }

  document.getElementById('btnAddLayer').onclick=()=>addLayer(`Lyr ${layers.length+1}`);
  document.getElementById('btnDelLayer').onclick=()=>{if(layers.length>1){layers.splice(activeIdx,1); activeIdx=Math.max(0,activeIdx-1); updateLayerUI();}};
  document.getElementById('btnDupLayer').onclick=()=>{
    const src=layers[activeIdx]; const c=makeCanvas(src.canvas.width, src.canvas.height); 
    const cx=c.getContext('2d', {willReadFrequently:true});
    cx.drawImage(src.canvas,0,0);
    layers.splice(activeIdx,0,{name:src.name+' copy', visible:src.visible, opacity:src.opacity, canvas:c, ctx:cx});
    updateLayerUI();
  };
  document.getElementById('btnClearActive').onclick=()=>{ 
      const ctx = layers[activeIdx].ctx; const oldD = ctx.getImageData(0,0, ctx.canvas.width, ctx.canvas.height);
      ctx.clearRect(0,0,cComp.width,cComp.height); redrawComposite(); 
      recordHistory(oldD, ctx.getImageData(0,0, ctx.canvas.width, ctx.canvas.height), activeIdx);
  };
  document.getElementById('layerOpacity').oninput=(e)=>{ if(layers[activeIdx]){ layers[activeIdx].opacity=+e.target.value; document.getElementById('vLayerOp').innerText=layers[activeIdx].opacity.toFixed(2); redrawComposite(); } };
  document.getElementById('btnExportPNG').onclick=()=>{
    const c=makeCanvas(cComp.width,cComp.height), x=c.getContext('2d'); x.fillStyle='#fff'; x.fillRect(0,0,c.width,c.height);
    for(let i=layers.length-1;i>=0;i--){ if(layers[i].visible) x.drawImage(layers[i].canvas,0,0); }
    const a=document.createElement('a'); a.download='art.png'; a.href=c.toDataURL(); a.click();
  };
  
  // (Clipboard functions remain same)
  let __clipboard = null; 
  function snapshotLayer(idx){
    if(!layers[idx]) return null;
    const ctx = layers[idx].ctx;
    return ctx.getImageData(0,0,cComp.width,cComp.height);
  }
  function doCopy(){
    if(!layers[activeIdx]) return;
    const ctx = layers[activeIdx].ctx;
    if(selection.active && selection.img){
      __clipboard = { kind:'rect', w: selection.img.width, h: selection.img.height, data: selection.img };
    }else{
      const img = snapshotLayer(activeIdx);
      __clipboard = { kind:'full', w: img.width, h: img.height, data: img };
    }
  }
  function doCut(){
    if(!layers[activeIdx]) return;
    const ctx = layers[activeIdx].ctx;
    const before = snapshotLayer(activeIdx);
    if(selection.active && selection.img){
      const r = normRect(selection.x, selection.y, selection.w, selection.h);
      try{
        const img = ctx.getImageData(r.x, r.y, r.w, r.h);
        __clipboard = { kind:'rect', w: img.width, h: img.height, data: img };
        ctx.clearRect(r.x, r.y, r.w, r.h);
      }catch(_){}
    }else{
      const img = before;
      __clipboard = { kind:'full', w: img.width, h: img.height, data: img };
      ctx.clearRect(0,0, ctx.canvas.width, ctx.canvas.height);
    }
    const after = snapshotLayer(activeIdx);
    recordHistory(before, after, activeIdx);
    redrawComposite();
  }
  function doPaste(){
    if(!__clipboard || !layers[activeIdx]) return;
    const ctx = layers[activeIdx].ctx;
    const before = snapshotLayer(activeIdx);
    if(__clipboard.kind === 'rect'){
      const px = (selection.active) ? Math.floor(selection.x) : Math.floor(lastPointer.x || 0);
      const py = (selection.active) ? Math.floor(selection.y) : Math.floor(lastPointer.y || 0);
      const nx = Math.max(0, Math.min(ctx.canvas.width - __clipboard.w, px));
      const ny = Math.max(0, Math.min(ctx.canvas.height - __clipboard.h, py));
      ctx.putImageData(__clipboard.data, nx, ny);
      selection.active = true; selection.moving = false; selection.x = nx; selection.y = ny; selection.w = __clipboard.w; selection.h = __clipboard.h;
      try{ selection.img = ctx.getImageData(nx, ny, __clipboard.w, __clipboard.h); }catch(_){ selection.img=null; }
    }else{
      ctx.putImageData(__clipboard.data, 0, 0);
      selection.active = false; selection.img = null; selection.moving = false;
    }
    const after = snapshotLayer(activeIdx);
    recordHistory(before, after, activeIdx);
    redrawComposite();
  }
  document.getElementById('btnCopy').onclick = doCopy;
  document.getElementById('btnCut').onclick = doCut;
  document.getElementById('btnDelete').onclick = ()=>{
    if(!layers[activeIdx]) return;
    const ctx = layers[activeIdx].ctx;
    const before = snapshotLayer(activeIdx);
    if(selection.active && selection.img){
      const r = normRect(selection.x, selection.y, selection.w, selection.h);
      ctx.clearRect(r.x, r.y, r.w, r.h);
      selection.active = false; selection.img=null; selection.moving=false; selection.origin=null;
    }else{
      ctx.clearRect(0,0, ctx.canvas.width, ctx.canvas.height);
    }
    const after = snapshotLayer(activeIdx);
    recordHistory(before, after, activeIdx);
    redrawComposite();
  };
  document.getElementById('btnPaste').onclick = doPaste;

  // Drag mode toggle
  const elDragMove = document.getElementById('dragModeMove');
  const elDragCopy = document.getElementById('dragModeCopy');
  function syncDragModeUI(){
    if(!elDragMove || !elDragCopy) return;
    elDragMove.classList.toggle('active', dragMode==='move');
    elDragCopy.classList.toggle('active', dragMode==='copy');
  }
  if(elDragMove) elDragMove.onclick = ()=>{ dragMode='move'; syncDragModeUI(); };
  if(elDragCopy) elDragCopy.onclick = ()=>{ dragMode='copy'; syncDragModeUI(); };
  syncDragModeUI();

  window.addEventListener('keydown', e => {
    const mod = e.ctrlKey || e.metaKey;
    if(!mod) return;
    const k = (e.key || '').toLowerCase();
    if(k === 'c'){ e.preventDefault(); doCopy(); }
    if(k === 'x'){ e.preventDefault(); doCut(); }
    if(k === 'v'){ e.preventDefault(); doPaste(); }
  });

  function downloadBlob(filename, blob){
    const a=document.createElement('a'); a.download=filename; a.href=URL.createObjectURL(blob);
    document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 30000);
  }
  function buildAnimxProject(){
    const traceEnabled = uiToggle?.checked ?? true;
    const yaw = Number(uiYaw?.value ?? 0); const pitch = Number(uiPitch?.value ?? 0);
    const zoom = 1.5; const op = Number(uiOp?.value ?? 0.35);
    const fps = Number(document.getElementById('animFps')?.value ?? 12);
    const loop = Number(document.getElementById('animLoop')?.value ?? 0);
    const layerPayload = layers.map(l => ({ id: l.id, name: l.name, visible: !!l.visible, opacity: Number(l.opacity ?? 1), png: l.canvas.toDataURL('image/png') }));
    return {
      magic: "ANIMX_PROJECT", schema_version: 1, created_at: new Date().toISOString(),
      canvas: { w: baseW, h: baseH },
      trace: { enabled: traceEnabled, yaw, pitch, zoom, opacity: op },
      layers: layerPayload,
      anim: { fps, loop, frames: [...animFrames] },
      ui: { active_layer_id: layers[activeIdx]?.id ?? null, active_frame_index: activeAnimIdx }
    };
  }
  document.getElementById('btnExportANIMX').onclick=()=>{
    const proj = buildAnimxProject(); const text = JSON.stringify(proj);
    const blob = new Blob([text], {type:'application/json'}); const ts = new Date().toISOString().replace(/[:.]/g,'-');
    downloadBlob(`project_${ts}.animx`, blob);
  };

  const fileImportAnimx = document.getElementById('fileImportAnimx');
  const btnImportANIMX = document.getElementById('btnImportANIMX');
  function isValidAnimxProject(obj){ return obj && obj.magic === 'ANIMX_PROJECT'; }
  function loadImage(dataUrl){ return new Promise((resolve, reject)=>{ const img = new Image(); img.onload = ()=>resolve(img); img.onerror = ()=>reject(new Error('fail')); img.src = dataUrl; }); }
  async function applyAnimxProject(proj){
    if(!isValidAnimxProject(proj)) throw new Error('invalid_animx');
    baseW = Math.max(1, Math.floor(proj.canvas.w)); baseH = Math.max(1, Math.floor(proj.canvas.h));
    cComp.width = cInput.width = baseW; cComp.height = cInput.height = baseH;
    applyZoom(1.0); elZoom.value = 100; vZoom.innerText = "100%";
    gComp.clearRect(0,0,baseW,baseH); gInput.clearRect(0,0,baseW,baseH);
    layers = []; __layerSeq = 0;
    for(const L of proj.layers){
      const c = makeCanvas(baseW, baseH); const ctx = c.getContext('2d', {willReadFrequently:true});
      try{ const img = await loadImage(L.png); ctx.drawImage(img, 0,0, c.width, c.height); }catch(_){ }
      layers.push({ id: String(L.id || `L${Date.now().toString(36)}_${(__layerSeq++).toString(36)}`), name: String(L.name || 'Layer'), visible: !!L.visible, opacity: Number(L.opacity)||1, canvas: c, ctx });
    }
    const wanted = proj.ui?.active_layer_id || null;
    activeIdx = Math.max(0, layers.findIndex(x=>x.id===wanted));
    if(proj.trace){
      uiToggle.checked = !!proj.trace.enabled; uiYaw.value = String(Number(proj.trace.yaw ?? 0));
      uiPitch.value = String(Number(proj.trace.pitch ?? 0)); uiOp.value = String(Number(proj.trace.opacity ?? 0.5));
    }
    updateMatrixView();
    animFrames = Array.isArray(proj.anim?.frames) ? proj.anim.frames.map(String) : [];
    activeAnimIdx = Math.max(0, Math.min(Number(proj.ui?.active_frame_index ?? 0), Math.max(0, animFrames.length-1)));
    updateLayerUI(); setTab('draw');
  }
  btnImportANIMX && (btnImportANIMX.onclick = ()=>{ fileImportAnimx && fileImportAnimx.click(); });
  fileImportAnimx && fileImportAnimx.addEventListener('change', async ()=>{
    const f = fileImportAnimx.files && fileImportAnimx.files[0]; if(!f) return;
    try{ const text = await f.text(); await applyAnimxProject(JSON.parse(text)); }catch(e){ alert('Import failed'); }finally{ fileImportAnimx.value = ''; }
  });

// ---- WebP Export Functions (Missing Logic) ----
  function u32le(v){ return [v&255,(v>>8)&255,(v>>16)&255,(v>>24)&255]; }
  function u16le(v){ return [v&255,(v>>8)&255]; }
  function u24le(v){ return [v&255,(v>>8)&255,(v>>16)&255]; }
  function str4(s){ return [s.charCodeAt(0),s.charCodeAt(1),s.charCodeAt(2),s.charCodeAt(3)]; }
  function readU32LE(d, o){ return (d[o]) | (d[o+1]<<8) | (d[o+2]<<16) | (d[o+3]<<24); }

  function parseWebPImageChunks(arrayBuffer){
    const d = new Uint8Array(arrayBuffer);
    if(String.fromCharCode(...d.slice(0,4)) !== 'RIFF' || String.fromCharCode(...d.slice(8,12)) !== 'WEBP'){ throw new Error('Not a WebP RIFF'); }
    let off = 12; const chunks = [];
    while(off + 8 <= d.length){
      const tag = String.fromCharCode(...d.slice(off, off+4));
      const size = readU32LE(d, off+4);
      const dataStart = off + 8; const dataEnd = dataStart + size;
      if(dataEnd > d.length) break;
      if(tag === 'VP8 ' || tag === 'VP8L' || tag === 'ALPH'){ chunks.push({tag, data: d.slice(dataStart, dataEnd)}); }
      off = dataEnd + (size % 2); 
    }
    return chunks;
  }

  function makeChunk(tag, dataBytes){
    const size = dataBytes.length; const pad = size % 2;
    const out = new Uint8Array(8 + size + pad);
    out.set(str4(tag), 0); out.set(u32le(size), 4); out.set(dataBytes, 8);
    return out;
  }

  function buildAnimatedWebP({width, height, loopCount, frames}){
    let hasAlpha = false;
    for(const f of frames){
      for(const c of f.chunks){ if(c.tag === 'ALPH' || c.tag === 'VP8L'){ hasAlpha = true; break; } }
      if(hasAlpha) break;
    }
    const flags = (1<<1) | (hasAlpha ? (1<<4) : 0);
    const vp8xPayload = new Uint8Array([ flags, 0,0,0, ...u24le(width-1), ...u24le(height-1) ]);
    const chunksOut = [makeChunk('VP8X', vp8xPayload)];
    const animPayload = new Uint8Array([ 0,0,0,0, ...u16le(loopCount) ]);
    chunksOut.push(makeChunk('ANIM', animPayload));
    for(const f of frames){
      const duration = Math.max(1, Math.min(0xFFFFFF, f.durationMs|0));
      const frameHdr = new Uint8Array([ ...u24le(0), ...u24le(0), ...u24le(width-1), ...u24le(height-1), ...u24le(duration), 0x00 ]);
      let payloadParts = [frameHdr];
      for(const c of f.chunks){ payloadParts.push(makeChunk(c.tag, c.data)); }
      const total = payloadParts.reduce((s,a)=>s+a.length, 0);
      const payload = new Uint8Array(total);
      let o=0; for(const part of payloadParts){ payload.set(part, o); o += part.length; }
      chunksOut.push(makeChunk('ANMF', payload));
    }
    const riffSize = 4 + chunksOut.reduce((s,c)=>s+c.length,0);
    const out = new Uint8Array(8 + riffSize);
    out.set(str4('RIFF'),0); out.set(u32le(riffSize),4); out.set(str4('WEBP'),8);
    let o=12; for(const c of chunksOut){ out.set(c,o); o+=c.length; }
    return out;
  }


  async function exportAnimationAnimatedWebP(){
    if(animFrames.length === 0){ alert('No frames in SEQUENCE.'); return; }
    
    const w = cComp.width, h = cComp.height;
    const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
    const tctx = tmp.getContext('2d');
    const frames = [];


    const fpsVal = Number(document.getElementById('animFps').value) || 12;
    const durationMs = Math.round(1000 / fpsVal);
    

    const loopVal = Number(document.getElementById('animLoop').value) || 0;

    const btn = document.getElementById('btnExportAnimWebP');
    const originalText = btn.innerText;
    btn.innerText = "Encoding...";

    try {
        for(const layerId of animFrames){
          const li = layers.findIndex(l=>l.id===layerId); if(li < 0) continue;
          
          tctx.clearRect(0,0,w,h); 
          tctx.fillStyle = '#ffffff'; 
          tctx.fillRect(0, 0, w, h);
          tctx.drawImage(layers[li].canvas, 0, 0);
    
          const blob = await new Promise(res=> tmp.toBlob(res, 'image/webp', 0.92));
          if(!blob || blob.type !== 'image/webp'){ 
             throw new Error('This browser does not support WebP encoding (returned ' + (blob ? blob.type : 'null') + ').'); 
          }
    
          const ab = await blob.arrayBuffer();
          const chunks = parseWebPImageChunks(ab);
          frames.push({chunks, durationMs});
        }
    

        const webpBytes = buildAnimatedWebP({width:w, height:h, loopCount:loopVal, frames});
        const outBlob = new Blob([webpBytes], {type:'image/webp'});
    
        const ts = new Date().toISOString().replace(/[:.]/g,'-');
        downloadBlob(`AnimX_${ts}.webp`, outBlob);
        
    } catch(err) {
        alert("Export Failed: " + err.message);
        console.error(err);
    } finally {
        btn.innerText = originalText;
    }
  }
  const btnExportAnimWebP = document.getElementById('btnExportAnimWebP');
  btnExportAnimWebP && (btnExportAnimWebP.onclick = ()=>{ exportAnimationAnimatedWebP(); });
  
  const refImage = document.getElementById('refImage');
  const uiToggle = document.getElementById('traceToggle') || document.getElementById('refToggle');
  const uiYaw = document.getElementById('traceYaw');
  const uiPitch = document.getElementById('tracePitch');
  const uiOp = document.getElementById('refOp');
  const CELL_W = 300, CELL_H = 300, START_CX = 150, START_CY = 150, CONTAINER_CW = 150, CONTAINER_CH = 150;
  const LABEL_YAW = { "-2":"-90", "-1":"-45", "0":"0", "1":"45", "2":"90" };
  const LABEL_PITCH = { "2":"30", "1":"15", "0":"0", "-1":"-15", "-2":"-30" };

  function updateMatrixView(){
    if(uiToggle && !uiToggle.checked){ if(refContainer) refContainer.style.display = 'none'; return; }
    if(refContainer) refContainer.style.display = 'block';
    const yawVal = parseInt(uiYaw.value); const pitchVal = parseInt(uiPitch.value); 
    const zoomVal = 1.5; const opVal = parseFloat(uiOp.value);
    const elYaw = document.getElementById('vYaw'), elPitch = document.getElementById('vPitch');
    const elOp = document.getElementById('vRefOp');
    if(elYaw) elYaw.innerText = (LABEL_YAW[yawVal] || yawVal) + "¬∞";
    if(elPitch) elPitch.innerText = (LABEL_PITCH[pitchVal] || pitchVal) + "¬∞";
    if(elOp) elOp.innerText = opVal.toFixed(2);
    if(refContainer){
        refContainer.style.opacity = opVal; 
        refContainer.style.transform = `translate(-50%, -50%) scale(${zoomVal})`;
        refContainer.style.width = `${CELL_W}px`;
        refContainer.style.height = `${CELL_H}px`;
    }
    const col = yawVal + 2; const row = 2 - pitchVal; 
    const cx = START_CX + col * CELL_W; const cy = START_CY + row * CELL_H;
    const targetX = CONTAINER_CW - cx; const targetY = CONTAINER_CH - cy;
    if(refImage){ refImage.style.transform = `translate(${targetX}px, ${targetY}px)`; }
  }

  const controls = [uiToggle, uiYaw, uiPitch, uiOp];
  controls.forEach(el => { if(el) { el.addEventListener('input', updateMatrixView); el.addEventListener('change', updateMatrixView); }});

// 1. iPad/Safari„ÅßÂãï„ÅèÂãïÁîªÂΩ¢Âºè„ÇíËá™Âãï„ÅßÈÅ∏„Å∂
  function pickMime(){
    const candidates = [
      'video/mp4;codecs=avc1.42E01E', // iPad/iPhone„ÅÆÊ®ôÊ∫ñ
      'video/mp4;codecs=avc1',
      'video/mp4',
      'video/webm;codecs=vp9',
      'video/webm'
    ];
    for (const m of candidates){
      if (MediaRecorder.isTypeSupported(m)) return m;
    }
    return '';
  }

  // 2. iPad„Åß„ÅÆ„Éï„Ç°„Ç§„É´‰øùÂ≠òÂ§±ÊïóÔºàÁ†¥ÊêçÔºâ„ÇíÈò≤„Åê
  function downloadBlob(filename, blob){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    document.body.appendChild(a);
    a.click();
    // iPad„ÅØ„Ç∑„Çπ„ÉÜ„É†„Åå„Éï„Ç°„Ç§„É´„ÇíÊãæ„ÅÜ„Åæ„ÅßÊôÇÈñì„Åå„Åã„Åã„Çã„Åü„ÇÅ„ÄÅ30ÁßíÂæÖ„Å£„Å¶„Åã„ÇâÊ∂àÂéª
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 30000);
  }

  // 3. „É°„Ç§„É≥„ÅÆÊõ∏„ÅçÂá∫„Åó„É≠„Ç∏„ÉÉ„ÇØ
  async function exportAnimationMP4() {
    if (animFrames.length === 0) { alert('No frames in SEQUENCE.'); return; }
    
    const btn = document.getElementById('btnExportAnimMP4');
    const originalText = btn.innerText;
    btn.innerText = "Encoding...";

    const fpsVal = Number(document.getElementById('animFps').value) || 12;
    const durationMs = 1000 / fpsVal;
    
    // „Ç≠„É£„É≥„Éê„Çπ„Åã„ÇâÊò†ÂÉè„Çπ„Éà„É™„Éº„É†„ÇíÂèñÂæó (0fps=ÊâãÂãï„Éï„É¨„Éº„É†ÈÄÅ„Çä)
    const stream = cComp.captureStream(fpsVal); 
    const track = stream.getVideoTracks()[0];
    const mimeType = pickMime();

    let recorder;
    try {
      // 200ms„Åî„Å®„Å´„Éá„Éº„Çø„ÇíÂêê„ÅçÂá∫„Åó(start(200))„ÄÅ„É°„É¢„É™ÁàÜÁô∫„ÇíÈò≤Ê≠¢
      recorder = new MediaRecorder(stream, mimeType ? { 
        mimeType,
        videoBitsPerSecond: 2500000 
      } : {});
    } catch(e) {
      alert("Recorder Error: " + e.message);
      btn.innerText = originalText;
      return;
    }

    const chunks = [];
    recorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };
    
    recorder.onstop = () => {
      if (chunks.length === 0) {
        alert("Export failed: No data recorded. (0 bytes)");
        btn.innerText = originalText;
        return;
      }
      const actualType = recorder.mimeType || 'video/mp4';
      const ext = actualType.includes('mp4') ? 'mp4' : 'webm';
      const blob = new Blob(chunks, { type: actualType });
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      const def = 'AnimX';
      let base = prompt('„Éï„Ç°„Ç§„É´ÂêçÔºàÊã°ÂºµÂ≠ê„Å™„ÅóÔºâ', def);
      if(base === null) { btn.innerText = originalText; return; } // „Ç≠„É£„É≥„Çª„É´
      base = base.trim() || def;
      base = base.replace(/[\\\/:*?"<>|]+/g, '_').slice(0,64);
      downloadBlob(`${base}.${ext}`, blob);
      btn.innerText = originalText;
      redrawComposite(); 
    };

    recorder.start(200); // „ÄêÈáçË¶Å„ÄëÂ∞èÂàª„Åø„Å´„Éá„Éº„Çø„ÇíÁ¢∫ÂÆö„Åï„Åõ„Å¶iPad„ÅÆ„É°„É¢„É™„ÇíÂÆà„Çã
    stopAnimPlayback(); 

    let i = 0;
    const recordOneFS = async () => {
      if (i >= animFrames.length) {
        // ÊúÄÂæå„ÅÆ„Ç≥„Éû„ÇíÂ∞ë„ÅóÈï∑„ÇÅ„Å´ÊÆã„Åó„Å¶ÁµÇ‰∫ÜÂá¶ÁêÜ
        setTimeout(() => recorder.stop(), 200);
        return;
      }

      const L = getLayerById(animFrames[i]);
      if (L) {
        // ÊèèÁîªÂá¶ÁêÜÔºöËÉåÊôØ„ÇíÊúÄÂàù„Å´Â°ó„Çä„Å§„Å∂„ÅôÔºàÁÑº„Åç‰ªò„ÅçÈò≤Ê≠¢Ôºâ
        gComp.setTransform(1,0,0,1,0,0);
        gComp.clearRect(0, 0, cComp.width, cComp.height);
        gComp.fillStyle = '#ffffff';
        gComp.fillRect(0, 0, cComp.width, cComp.height);
        gComp.globalAlpha = 1.0;
        gComp.drawImage(L.canvas, 0, 0);
        
      requestAnimationFrame(() => {});
        if (track && track.requestFrame) {
          track.requestFrame();
        }
      }

      i++;
      // setTimeout„Åß1„Ç≥„Éû„Åö„Å§Á¢∫ÂÆü„Å´„Ç®„É≥„Ç≥„Éº„ÉâÊôÇÈñì„ÇíÁ¢∫‰øù
      setTimeout(recordOneFS, durationMs);
    };

    recordOneFS();
  }

  document.getElementById('btnExportAnimMP4').onclick = exportAnimationMP4;

  addLayer("Line Art"); updateMatrixView(); setTab('draw'); 
  })();
</script>
</body>
</html>